
基本概念
========

.. contents::
   :local:
   :depth: 1


シミュレーション機能
--------------------

Choreonoidはシミュレーション機能を備えており、ロボットシミュレータとして利用することが可能です。ロボットや環境物体がどのように動くかを計算によってシミュレートし、その結果を3DCGによるアニメーションで表示したり、データとして出力します。この機能を用いることで、実際のロボットを動かすことなく、ハードウェア設計やソフトウェアに関する検証を行ったり、操作や運用の練習を行うといったことが可能となります。

シミュレーションの対象となるのは、 :doc:`../handling-models/index` で紹介した「ボディモデル」です。ボディモデルをボディアイテムとして読み込んでおき、さらにそれらをワールドアイテムでひとつの仮想世界に所属させることで、この仮想世界を対象としたシミュレーションが可能となります。


物理エンジン
------------

シミュレータのコアとなる部分は、物体が物理的にどのように動くかを計算する部分で、これを「物理エンジン」と呼びます。物理計算のアルゴリズムは様々なものが考案されており、それらの実装である物理エンジンについても、これまで様々なものが開発されています。シミュレーション可能なモデルや物理現象はエンジン次第ですし、シミュレーションの精度、安定性、計算速度といった特性もエンジンによって異なってきますので、シミュレーションの対象や目的に応じてエンジンを使い分けることが重要です。この観点から、Choreonoidは様々な物理エンジンを使えるように設計されています。

.. _simulation_simulator_item:

シミュレータアイテム
--------------------

Choreonoidにおいて物理エンジンは「シミュレータアイテム」というプロジェクトアイテムとして表現されます。これは物理エンジンをChoreonoidのシミュレーション機能に組み込むためのもので、そのための基盤となるAPIを備えたものです。実際に使うのはシミュレータアイテムを継承したアイテムで、物理エンジンごとにそれに対応したシミュレータアイテムが定義されることになります。具体的には、以下のようなシミュレータアイテムが利用可能となっています。

* **AISTシミュレータアイテム**

 Choreonoid標準のシミュレータアイテムで、独自の物理計算エンジンによりシミュレーションを行います。

* **ODEシミュレータアイテム**, **Bulletシミュレータアイテム**, **PhysXシミュレータアイテム**

 それぞれ、ライブラリとして外部から利用可能な物理エンジンである `Open Dynamics Engine (ODE) <http://www.ode.org/>`_ 、 `Bullet Physics Library <http://bulletphysics.org>`_, `PhysX <https://developer.nvidia.com/gameworks-physx-overview>`_ を利用するシミュレータアイテムです。対応するライブラリをインストールして、ODEプラグイン、Bulletプラグイン、もしくはPhysXプラグインをビルドすることにより利用可能となります。

.. note:: 物理計算においてはシミュレーション対象の物体間に生じる干渉の検出も必要であり、通常はこれを行う干渉検出器も物理計算エンジンに含まれます。一方で、 :doc:`../handling-models/index` の :doc:`../handling-models/collision-detection` で解説したように、Choreonoidの基本機能として用意された干渉検出機能も存在し、こちらについても様々な干渉検出器が利用可能となっています (:ref:`handling-models_switch-collision-detector`)。シミュレータアイテムによっては基本機能として用意された干渉検出機能から、任意の干渉検出器を利用可能となっているものもあります。

.. _simulation_subsimulator:

サブシミュレータ
----------------

物理計算は基本的にシミュレータアイテムによって行われますが、これを補足して様々なシミュレーション機能を実現するための「サブシミュレータ」もアイテムとして利用可能となっています。

例えば、ロボットに搭載されたカメラや距離センサの機能をシミュレートして、カメラ画像や距離画像をシミュレーション中にも取得できるようにしたい場合があります。この機能を追加するサブシミュレータとして :ref:`simulation-gl-vision-simulator` アイテムが用意されています。このサブシミュレータでは、3DCG表示と同様の描画処理をカメラや距離センサの視点で内部的に行うことにより、センサの出力をシミュレートします。これを「物理エンジン」との対比で言えば、「視覚エンジン」とでも言うことができるでしょう。この機能は物理計算のアルゴリズムには依存しませんので、どのシミュレータアイテムとも組み合わせて利用することが可能です。

サブシミュレータでは、仮想世界の状況を監視して、それに応じた出力を行ったり、仮想世界に手を加えるといった枠組みで、他にも様々な機能を実現できます。

コントローラ
------------

ロボットを動かすためにはそれを制御するプログラムが必要で、これを「コントローラ」と呼びます。シミュレーションにおいても、ロボットを動かすためにはコントローラが必要です。一般的には、ロボット実機を動かすためのコントローラと、シミュレーションで用いるコントローラについて、共通のものを使います。このようにすることで、コントローラの開発や検証をシミュレータ上で効率的に行おうというわけです。また、こうしておけば、開発したロボットシステムのユーザがその操作や運用をシミュレータ上で練習することも可能となります。

いずれにしても、ロボットを動かすためにはコントローラが必要であり、これもシミュレーションを構成するの主要な要素のひとつとなります。

.. _simulation-concept-controller-item:

コントローラアイテム
--------------------

Choreonoidのシミュレーション機能では、コントローラは「コントローラアイテム」というプロジェクトアイテムとして表現されます。実際にはこれを継承したアイテム型を用いて、コントローラアイテムとは別に実装されたコントローラ本体を稼働させます。コントローラ本体の形式は様々なものがあり得ますが、ある形式に対応したコントローラアイテムが用意されていれば、その形式のコントローラを使用することが可能となります。例えば、RTミドルウェアのソフトウェアコンポーネントである「RTコンポーネント」について、これに対応した「ボディRTCアイテム」というコントローラアイテムが利用可能です。

コントローラアイテムの使用方法については、 :doc:`howto-use-controller` で解説します。


ロボットとコントローラ間の入出力
--------------------------------

コントローラがロボットを制御するためにまず必要なことは、ロボットとの間で各種データの入出力を行うことです。すなわち、コントローラはまずロボットに搭載された各種センサからの入力でロボットや環境の状態を取得し、これに基づく制御計算を行った後、決定した指令値をロボットのアクチュエータ等に出力するわけです。

入力の対象となるものとして、具体的に以下のような要素があります。

* 回転関節の関節角度
* 直動関節の関節並進量
* 力センサ
* 加速度センサ
* 角加速度センサ（レートジャイロ）
* カメラ画像
* レンジセンサ距離画像

出力の対象としては、以下のような要素があります。

* 回転関節にかけるトルク
* 直動関節にかける力
* 各種デバイス（ライト等）の操作指令（オン／オフ等）

コントローラアイテムについては、これらの入出力用のインタフェースを規定するものだと思ってもらえればよいかと思います。

実際の入出力方法については、 :doc:`howto-implement-controller` で解説します。

プラグインの活用
----------------

シミュレータアイテム、サブシミュレータアイテム、コントローラアイテムについては、それぞれの継承アイテム型をプラグインによって追加することができます。これにより、

* 利用可能な物理エンジンを追加する
* シミュレーション機能を拡張する
* 対応可能なコントローラの形式を追加する

といったことが可能です。Choreonoidはそのようにシミュレーション機能自体を拡張するためのプラットフォームであるとも言えるでしょう。

シミュレータアイテムの実装方法については、:doc:`../plugin-development/index` の :doc:`../plugin-development/ode-plugin` が参考になるかと思います。
